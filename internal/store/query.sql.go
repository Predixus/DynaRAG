// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package store

import (
	"context"

	"github.com/Predixus/DynaRAG/types"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createDocument = `-- name: CreateDocument :one
INSERT INTO documents (file_path)
VALUES ($1)
ON CONFLICT (file_path) DO UPDATE 
SET updated_at = CURRENT_TIMESTAMP
RETURNING id, file_path, total_chunk_size, created_at, updated_at
`

func (q *Queries) CreateDocument(ctx context.Context, filePath string) (Document, error) {
	row := q.db.QueryRow(ctx, createDocument, filePath)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.FilePath,
		&i.TotalChunkSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEmbedding = `-- name: CreateEmbedding :one
INSERT INTO embeddings (
    document_id,
    model_name,
    embedding,
    chunk_text,
    chunk_size,
    created_at,
    metadata,
    metadata_hash,
    embedding_text
) VALUES (
    $1, $2, $3, $4, length($4), DEFAULT, $5, $6, $7
)
RETURNING id, document_id, model_name, embedding, chunk_text, chunk_size, created_at, metadata, metadata_hash, embedding_text
`

type CreateEmbeddingParams struct {
	DocumentID    pgtype.Int8
	ModelName     EmbeddingModel
	Embedding     pgvector.Vector
	ChunkText     string
	Metadata      types.JSONMap
	MetadataHash  pgtype.Text
	EmbeddingText pgtype.Text
}

func (q *Queries) CreateEmbedding(ctx context.Context, arg CreateEmbeddingParams) (Embedding, error) {
	row := q.db.QueryRow(ctx, createEmbedding,
		arg.DocumentID,
		arg.ModelName,
		arg.Embedding,
		arg.ChunkText,
		arg.Metadata,
		arg.MetadataHash,
		arg.EmbeddingText,
	)
	var i Embedding
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.ModelName,
		&i.Embedding,
		&i.ChunkText,
		&i.ChunkSize,
		&i.CreatedAt,
		&i.Metadata,
		&i.MetadataHash,
		&i.EmbeddingText,
	)
	return i, err
}

const deleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents
WHERE id = $1
`

func (q *Queries) DeleteDocument(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDocument, id)
	return err
}

const deleteEmbeddings = `-- name: DeleteEmbeddings :exec
DELETE FROM embeddings
`

func (q *Queries) DeleteEmbeddings(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteEmbeddings)
	return err
}

const findSimilarEmbeddingsInDocument = `-- name: FindSimilarEmbeddingsInDocument :many
WITH similarity_scores AS (
    SELECT 
        e.id,
        e.document_id,
        e.chunk_text,
        e.chunk_size,
        e.metadata,
        d.file_path,
        1 - (e.embedding <=> $2::vector) as similarity
    FROM embeddings e
    JOIN documents d ON d.id = e.document_id
    WHERE e.document_id = $3
      AND e.model_name = $4
      AND 1 - (e.embedding <=> $2::vector) > $5
      AND ($6::text IS NULL OR $6::text = e.metadata_hash)
)
SELECT id, document_id, chunk_text, chunk_size, metadata, file_path, similarity
FROM similarity_scores
ORDER BY similarity DESC
LIMIT $1
`

type FindSimilarEmbeddingsInDocumentParams struct {
	MaxResults          int32
	QueryEmbedding      pgvector.Vector
	DocumentID          pgtype.Int8
	ModelName           EmbeddingModel
	SimilarityThreshold pgvector.Vector
	MetadataHash        pgtype.Text
}

type FindSimilarEmbeddingsInDocumentRow struct {
	ID         int64
	DocumentID pgtype.Int8
	ChunkText  string
	ChunkSize  int32
	Metadata   types.JSONMap
	FilePath   string
	Similarity int32
}

func (q *Queries) FindSimilarEmbeddingsInDocument(ctx context.Context, arg FindSimilarEmbeddingsInDocumentParams) ([]FindSimilarEmbeddingsInDocumentRow, error) {
	rows, err := q.db.Query(ctx, findSimilarEmbeddingsInDocument,
		arg.MaxResults,
		arg.QueryEmbedding,
		arg.DocumentID,
		arg.ModelName,
		arg.SimilarityThreshold,
		arg.MetadataHash,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindSimilarEmbeddingsInDocumentRow
	for rows.Next() {
		var i FindSimilarEmbeddingsInDocumentRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.ChunkText,
			&i.ChunkSize,
			&i.Metadata,
			&i.FilePath,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTopKNNEmbeddings = `-- name: FindTopKNNEmbeddings :many
SELECT 
    e.id,
    e.document_id,
    e.chunk_text,
    e.chunk_size,
    d.file_path,
    e.metadata,
    (e.embedding <=> $1::vector)::float8 as distance,
    (1 - (e.embedding <=> $1::vector))::float8 as similarity
FROM embeddings e
JOIN documents d ON d.id = e.document_id
WHERE e.model_name = $2
  AND ($3::text IS NULL OR $3::text = e.metadata_hash)
ORDER BY e.embedding <=> $1::vector ASC
LIMIT $4
`

type FindTopKNNEmbeddingsParams struct {
	QueryEmbedding pgvector.Vector
	ModelName      EmbeddingModel
	MetadataHash   pgtype.Text
	K              int32
}

type FindTopKNNEmbeddingsRow struct {
	ID         int64
	DocumentID pgtype.Int8
	ChunkText  string
	ChunkSize  int32
	FilePath   string
	Metadata   types.JSONMap
	Distance   float64
	Similarity float64
}

func (q *Queries) FindTopKNNEmbeddings(ctx context.Context, arg FindTopKNNEmbeddingsParams) ([]FindTopKNNEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, findTopKNNEmbeddings,
		arg.QueryEmbedding,
		arg.ModelName,
		arg.MetadataHash,
		arg.K,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTopKNNEmbeddingsRow
	for rows.Next() {
		var i FindTopKNNEmbeddingsRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.ChunkText,
			&i.ChunkSize,
			&i.FilePath,
			&i.Metadata,
			&i.Distance,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocument = `-- name: GetDocument :one
SELECT id, file_path, total_chunk_size, created_at, updated_at FROM documents WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDocument(ctx context.Context, id int64) (Document, error) {
	row := q.db.QueryRow(ctx, getDocument, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.FilePath,
		&i.TotalChunkSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmbedding = `-- name: GetEmbedding :one
SELECT e.id, e.document_id, e.model_name, e.embedding, e.chunk_text, e.chunk_size, e.created_at, e.metadata, e.metadata_hash, e.embedding_text FROM embeddings e
JOIN documents d ON d.id = e.document_id
WHERE e.id = $1 LIMIT 1
`

func (q *Queries) GetEmbedding(ctx context.Context, id int64) (Embedding, error) {
	row := q.db.QueryRow(ctx, getEmbedding, id)
	var i Embedding
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.ModelName,
		&i.Embedding,
		&i.ChunkText,
		&i.ChunkSize,
		&i.CreatedAt,
		&i.Metadata,
		&i.MetadataHash,
		&i.EmbeddingText,
	)
	return i, err
}

const getStats = `-- name: GetStats :one
SELECT 
    COUNT(DISTINCT d.id) as document_count,
    COUNT(e.id) as chunk_count,
    COALESCE(SUM(e.chunk_size), 0) as total_bytes
FROM documents d
LEFT JOIN embeddings e ON e.document_id = d.id
`

type GetStatsRow struct {
	DocumentCount int64
	ChunkCount    int64
	TotalBytes    interface{}
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRow(ctx, getStats)
	var i GetStatsRow
	err := row.Scan(&i.DocumentCount, &i.ChunkCount, &i.TotalBytes)
	return i, err
}

const getStorageStats = `-- name: GetStorageStats :one
SELECT 
    COUNT(e.id) as embedding_count,
    SUM(e.chunk_size) as total_bytes,
    COUNT(DISTINCT d.id) as document_count
FROM embeddings e
LEFT JOIN documents d ON e.document_id = d.id
`

type GetStorageStatsRow struct {
	EmbeddingCount int64
	TotalBytes     int64
	DocumentCount  int64
}

func (q *Queries) GetStorageStats(ctx context.Context) (GetStorageStatsRow, error) {
	row := q.db.QueryRow(ctx, getStorageStats)
	var i GetStorageStatsRow
	err := row.Scan(&i.EmbeddingCount, &i.TotalBytes, &i.DocumentCount)
	return i, err
}

const listChunks = `-- name: ListChunks :many
SELECT 
    e.id,
    e.chunk_text,
    e.metadata,
    e.chunk_size,
    e.model_name,
    e.created_at,
    d.file_path,
    d.id as document_id
FROM embeddings e
JOIN documents d ON d.id = e.document_id
WHERE ($1::text IS NULL OR e.metadata_hash = $1::text)
ORDER BY e.created_at DESC
`

type ListChunksRow struct {
	ID         int64
	ChunkText  string
	Metadata   types.JSONMap
	ChunkSize  int32
	ModelName  EmbeddingModel
	CreatedAt  pgtype.Timestamptz
	FilePath   string
	DocumentID int64
}

func (q *Queries) ListChunks(ctx context.Context, metadataHash pgtype.Text) ([]ListChunksRow, error) {
	rows, err := q.db.Query(ctx, listChunks, metadataHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChunksRow
	for rows.Next() {
		var i ListChunksRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkText,
			&i.Metadata,
			&i.ChunkSize,
			&i.ModelName,
			&i.CreatedAt,
			&i.FilePath,
			&i.DocumentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocumentEmbeddings = `-- name: ListDocumentEmbeddings :many
SELECT e.id, e.document_id, e.model_name, e.embedding, e.chunk_text, e.chunk_size, e.created_at, e.metadata, e.metadata_hash, e.embedding_text FROM embeddings e
JOIN documents d ON d.id = e.document_id
WHERE e.document_id = $1
  AND ($2::text IS NULL OR $2::text = e.metadata_hash)
`

type ListDocumentEmbeddingsParams struct {
	DocumentID   pgtype.Int8
	MetadataHash pgtype.Text
}

func (q *Queries) ListDocumentEmbeddings(ctx context.Context, arg ListDocumentEmbeddingsParams) ([]Embedding, error) {
	rows, err := q.db.Query(ctx, listDocumentEmbeddings, arg.DocumentID, arg.MetadataHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Embedding
	for rows.Next() {
		var i Embedding
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.ModelName,
			&i.Embedding,
			&i.ChunkText,
			&i.ChunkSize,
			&i.CreatedAt,
			&i.Metadata,
			&i.MetadataHash,
			&i.EmbeddingText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocuments = `-- name: ListDocuments :many
SELECT id, file_path, total_chunk_size, created_at, updated_at FROM documents ORDER BY created_at DESC
`

func (q *Queries) ListDocuments(ctx context.Context) ([]Document, error) {
	rows, err := q.db.Query(ctx, listDocuments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Document
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.FilePath,
			&i.TotalChunkSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
